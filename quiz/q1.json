{
  "questions": [
    {
      "id": "q1",
      "question": "Which of the following can be used to asynchronously send a command over a list handles?",
      "options": [
        { "id": "a", "text": "neg[handles](`func;10;20)", "isCorrect": false },
        { "id": "b", "text": "-25!(handles;(`func;10;20))", "isCorrect": true },
        { "id": "c", "text": "neg[handles]@\\:(`func;10;20)", "isCorrect": true },
        { "id": "d", "text": "neg[handles]each(`func;10;20)", "isCorrect": false }
      ]
    },
    {
      "id": "q2",
      "question": "What might one find at the root level of a date partitioned hdb directory?",
      "options": [
        { "id": "a", "text": "sym file", "isCorrect": true },
        { "id": "b", "text": "table folders", "isCorrect": false },
        { "id": "c", "d": "date partition folders", "isCorrect": true },
        { "id": "d", "text": "par.txt", "isCorrect": true }
      ]
    },
    {
      "id": "q3",
      "question": "How might I get the unique elements across two lists L1 and L2?",
      "options": [
        { "id": "a", "text": "L1 inter L2", "isCorrect": false },
        { "id": "b", "text": "L1,L2", "isCorrect": false },
        { "id": "c", "d": "distinct L1,L2", "isCorrect": true },
        { "id": "d", "text": "L1 union L2", "isCorrect": true }
      ]
    },
    {
      "id": "q4",
      "question": "How do I find the number of healthy chunks in a log file L?",
      "options": [
        { "id": "a", "text": "-11!L", "isCorrect": false },
        { "id": "b", "text": "-11!(-2;L)", "isCorrect": true },
        { "id": "c", "d": "-11!(-1;L)", "isCorrect": false },
        { "id": "d", "text": "-11!(n;L)", "isCorrect": false }
      ]
    },
    {
      "id": "q5",
      "question": "How do I flush a handle to ensure any queued messaged leave now rather than at the end of the current chain of execution?",
      "options": [
        { "id": "a", "text": "h`", "isCorrect": false },
        { "id": "b", "text": "neg[h][]", "isCorrect": true },
        { "id": "c", "d": "neg[h](::)", "isCorrect": true },
        { "id": "d", "text": "h(::)", "isCorrect": false }
      ]
    },
    {
      "id": "q6",
      "question": "Which attribute(s) do not carry any overhead?",
      "options": [
        { "id": "a", "text": "grouped (`g#)", "isCorrect": false },
        { "id": "b", "text": "sorted (`s#)", "isCorrect": true },
        { "id": "c", "d": "unique (`u#)", "isCorrect": false },
        { "id": "d", "text": "parted (`p#)", "isCorrect": false }
      ]
    },
    {
      "id": "q7",
      "question": "What would be the result of ` sv `a`b",
      "options": [
        { "id": "a", "text": "`:a/b", "isCorrect": false },
        { "id": "b", "text": "`:a/b/", "isCorrect": false },
        { "id": "c", "d": "`a.b", "isCorrect": true },
        { "id": "d", "text": "'length", "isCorrect": false }
      ]
    },
    {
      "id": "q8",
      "question": "What would be the result of ` sv `:a`b",
      "options": [
        { "id": "a", "text": "`:a/b", "isCorrect": true },
        { "id": "b", "text": "length", "isCorrect": false },
        { "id": "c", "d": "`a.b", "isCorrect": false },
        { "id": "d", "text": "`:a/b/", "isCorrect": false }
      ]
    },
    {
      "id": "q9",
      "question": "If I have the dictionary d:`a`b!(1 2 3;10 20 30) - how would I return d with the 20 doubled to 40?",
      "options": [
        { "id": "a", "text": "@[d;(`b;1);*;2]", "isCorrect": false },
        { "id": "b", "text": "d[`b;1]*2", "isCorrect": false },
        { "id": "c", "d": ".[d;(`b;1);*;2]", "isCorrect": true },
        { "id": "d", "text": ".[d;(`b;1);2*]", "isCorrect": true }
      ]
    },
    {
      "id": "q10",
      "question": "Which of the following statement is true of aj[`sym`time;trade;quote] in order to optimise performance?",
      "options": [
        { "id": "a", "text": "The trade table should have time in ascending order", "isCorrect": false },
        { "id": "b", "text": "The quote table should have the parted or grouped attribute on sym, and the sorted attribute on time", "isCorrect": false },
        { "id": "c", "d": "The trade table should have the parted or grouped attribute on sym", "isCorrect": false },
        { "id": "d", "text": "The quote table should have the parted or grouped attribute on sym. aj expects that time will be in ascending order within each sym.", "isCorrect": true }
      ]
    },
    {
      "id": "q11",
      "question": "If I want to soft delete a column exchange from the trade table in a hdb, in each date/trade folder I would:",
      "options": [
        { "id": "a", "text": "Delete the exchange column file", "isCorrect": false },
        { "id": "b", "text": "Remove exchange from the .d file", "isCorrect": true },
        { "id": "c", "d": "Delete the .d file", "isCorrect": false },
        { "id": "d", "text": "Delete the exchange column file and remove exchange from the .d file", "isCorrect": false }
      ]
    },
    {
      "id": "q12",
      "question": "To initilise a tickerplant binary log file .u.L, to which I have opened a handle .u.l, I should do:",
      "options": [
        { "id": "a", "text": ".u.l 0: ()", "isCorrect": false },
        { "id": "b", "text": ".u.l set ()", "isCorrect": false },
        { "id": "c", "d": ".u.l set enlist ()", "isCorrect": false },
        { "id": "d", "text": ".u.L set ()", "isCorrect": true }
      ]
    },
    {
      "id": "q13",
      "question": "To write some data for the trade table to a tickerplant binary log file .u.L, to which I have opened a handle .u.l, I should do:",
      "options": [
        { "id": "a", "text": ".u.L 0: enlist(`upd;`trade;x)", "isCorrect": false },
        { "id": "b", "text": ".u.l 0: enlist(`upd;`trade;x)", "isCorrect": false },
        { "id": "c", "d": ".u.l enlist(`upd;`trade;x)", "isCorrect": true },
        { "id": "d", "text": ".u.L (`upd;`trade;x)", "isCorrect": false }
      ]
    },
    {
      "id": "q14",
      "question": "To add the symbols `A`B to a symbol vector file `:sym on disk, I can do:",
      "options": [
        { "id": "a", "text": "`:sym$`A`B", "isCorrect": false },
        { "id": "b", "text": "`:sym,:`A`B", "isCorrect": false },
        { "id": "c", "d": "@[`:.;`sym;,;`A`B]", "isCorrect": true },
        { "id": "d", "text": "`sym?`A`B", "isCorrect": true }
      ]
    },
    {
      "id": "q15",
      "question": "Which of the following is true:",
      "options": [
        { "id": "a", "text": "upsert works only when the left argument is a keyed table", "isCorrect": true },
        { "id": "b", "text": "insert may fail unless the left argument is an unkeyed table name", "isCorrect": false },
        { "id": "c", "d": "insert expects the right argument to be a table or a list of column data", "isCorrect": true },
        { "id": "d", "text": "upsert epects the right argument to be a table or a list of row data", "isCorrect": true }
      ]
    }
  ]
}